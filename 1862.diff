diff --git a/data/theme/gnome-shell-sass/widgets/_window-picker.scss b/data/theme/gnome-shell-sass/widgets/_window-picker.scss
index b3b93f291a1c01653f922abed428df0a3e376110..fa3f19194502ff35f8331b88eeaf54cb972f46e1 100644
--- a/data/theme/gnome-shell-sass/widgets/_window-picker.scss
+++ b/data/theme/gnome-shell-sass/widgets/_window-picker.scss
@@ -48,6 +48,5 @@ $window_close_button_padding: 3px;
 .workspace-background {
   // keep in sync with BACKGROUND_CORNER_RADIUS_PIXELS in workspace.js
   border-radius: 30px;
-  background-color: $osd_bg_color;
   box-shadow: 0 4px 16px 4px transparentize(darken($osd_bg_color, 30%), 0.7);
 }
diff --git a/src/st/st-theme-node-drawing.c b/src/st/st-theme-node-drawing.c
index f839d990ed93cb9820485c4df641b30d1e6c9e61..80ade9319792864734c6252081718d626458da2d 100644
--- a/src/st/st-theme-node-drawing.c
+++ b/src/st/st-theme-node-drawing.c
@@ -51,6 +51,11 @@ typedef struct {
   float          resource_scale;
 } StCornerSpec;
 
+typedef enum {
+  ST_PAINT_BORDERS_MODE_COLOR,
+  ST_PAINT_BORDERS_MODE_SILHOUETTE
+} StPaintBordersMode;
+
 static void
 elliptical_arc (cairo_t *cr,
                 double   x_center,
@@ -409,7 +414,12 @@ st_theme_node_lookup_corner (StThemeNode    *node,
   if (corner.color.alpha == 0 &&
       corner.border_color_1.alpha == 0 &&
       corner.border_color_2.alpha == 0)
-    return NULL;
+    {
+      if (node->box_shadow == NULL)
+        return NULL;
+      else  /* We still need a corner texture to render the box-shadow */
+        corner.color = (ClutterColor) {0, 0, 0, 255};
+    }
 
   key = corner_to_string (&corner);
   texture = st_texture_cache_load (cache, key, ST_TEXTURE_CACHE_POLICY_FOREVER, load_corner, &corner, NULL);
@@ -1355,6 +1365,7 @@ st_theme_node_prerender_background (StThemeNode *node,
 static void st_theme_node_paint_borders (StThemeNodePaintState *state,
                                          CoglFramebuffer       *framebuffer,
                                          const ClutterActorBox *box,
+                                         StPaintBordersMode     mode,
                                          guint8                 paint_opacity);
 
 void
@@ -1580,7 +1591,7 @@ st_theme_node_render_resources (StThemeNodePaintState *state,
         state->box_shadow_pipeline = _st_create_shadow_pipeline (box_shadow_spec,
                                                                  state->prerendered_texture,
                                                                  state->resource_scale);
-      else if (node->background_color.alpha > 0 || has_border)
+      else
         st_theme_node_prerender_shadow (state);
     }
 
@@ -1697,6 +1708,7 @@ static void
 st_theme_node_paint_borders (StThemeNodePaintState *state,
                              CoglFramebuffer       *framebuffer,
                              const ClutterActorBox *box,
+                             StPaintBordersMode     mode,
                              guint8                 paint_opacity)
 {
   StThemeNode *node = state->node;
@@ -1708,6 +1720,7 @@ st_theme_node_paint_borders (StThemeNodePaintState *state,
   int corner_id, side_id;
   ClutterColor border_color;
   guint8 alpha;
+  gboolean corners_are_transparent;
 
   width = box->x2 - box->x1;
   height = box->y2 - box->y1;
@@ -1802,8 +1815,12 @@ st_theme_node_paint_borders (StThemeNodePaintState *state,
         }
     }
 
+  corners_are_transparent = mode == ST_PAINT_BORDERS_MODE_COLOR &&
+                            node->background_color.alpha == 0 &&
+                            node->border_color[0].alpha == 0;
+
   /* corners */
-  if (max_border_radius > 0 && paint_opacity > 0)
+  if (max_border_radius > 0 && paint_opacity > 0 && !corners_are_transparent)
     {
       for (corner_id = 0; corner_id < 4; corner_id++)
         {
@@ -1852,7 +1869,9 @@ st_theme_node_paint_borders (StThemeNodePaintState *state,
     }
 
   /* background color */
-  alpha = paint_opacity * node->background_color.alpha / 255;
+  alpha = mode == ST_PAINT_BORDERS_MODE_SILHOUETTE ?
+          255 :
+          paint_opacity * node->background_color.alpha / 255;
   if (alpha > 0)
     {
       st_theme_node_ensure_color_pipeline (node);
@@ -2159,16 +2178,21 @@ st_theme_node_paint_sliced_shadow (StThemeNodePaintState *state,
       rectangles[idx++] = s_bottom;
     }
 
-  /* Center middle */
-  rectangles[idx++] = left;
-  rectangles[idx++] = top;
-  rectangles[idx++] = right;
-  rectangles[idx++] = bottom;
+  /* Center middle is visible? */
+  if (paint_opacity < 255 ||
+      xoffset > shadow_blur_radius || left < 0 ||
+      yoffset > shadow_blur_radius || top < 0)
+    {
+      rectangles[idx++] = left;
+      rectangles[idx++] = top;
+      rectangles[idx++] = right;
+      rectangles[idx++] = bottom;
 
-  rectangles[idx++] = s_left;
-  rectangles[idx++] = s_top;
-  rectangles[idx++] = s_right;
-  rectangles[idx++] = s_bottom;
+      rectangles[idx++] = s_left;
+      rectangles[idx++] = s_top;
+      rectangles[idx++] = s_right;
+      rectangles[idx++] = s_bottom;
+    }
 
   if (xend > right)
     {
@@ -2307,7 +2331,7 @@ st_theme_node_prerender_shadow (StThemeNodePaintState *state)
                               state->resource_scale, 1);
       cogl_framebuffer_clear4f (framebuffer, COGL_BUFFER_BIT_COLOR, 0, 0, 0, 0);
 
-      st_theme_node_paint_borders (state, framebuffer, &box, 0xFF);
+      st_theme_node_paint_borders (state, framebuffer, &box, ST_PAINT_BORDERS_MODE_SILHOUETTE, 0xFF);
 
       state->box_shadow_pipeline = _st_create_shadow_pipeline (st_theme_node_get_box_shadow (node),
                                                                buffer, state->resource_scale);
@@ -2663,7 +2687,7 @@ st_theme_node_paint (StThemeNode           *node,
     }
   else
     {
-      st_theme_node_paint_borders (state, framebuffer, box, paint_opacity);
+      st_theme_node_paint_borders (state, framebuffer, box, ST_PAINT_BORDERS_MODE_COLOR, paint_opacity);
     }
 
   st_theme_node_paint_outline (node, framebuffer, box, paint_opacity);
